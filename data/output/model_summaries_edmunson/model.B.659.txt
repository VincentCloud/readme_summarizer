cesiummeshvisualizer document demos（示例中常用操作有：左击发射，q、a——左、右摆动，w、s、a、d——前进、后退、左转弯、右转弯） csg lod meshvisualizer physicshelloworld physicscloth physicsvehicle physicsterrain physicssoftbodyvolume physicssoftbodyvolume2 physicssoftbodyrope physicsconvexbreak referencemesh volumerendering fluid2d example 携源码示例和文档，诚意奉献，httpsgithub.commikesweicesiummeshvisualizer ， 名字不重要。 个人觉得threejs里的mesh、geometry、material极好，尤其是各个属性可以独立地、动态地编辑的特点，是目前在cesium的primitive中没有充分体现的。比如 你渲染一个立方体，想要旋转，竟然还需要自己去算新的modelmatrix；再比如画个波动的水面竟然不能只修改顶点位置属性，修改完顶点位置后竟然需要移除旧的 primitive再创建一个。。。也许我没找到接口，但是真心难找啊！还好，稍微扒过cesium primitive的都知道，再往稍微底层一点的还有drawcommand可以灵活使用， 但是也太灵活，代码量大，还容易出错，所以决定自己模仿threejs的mesh、geometry、material并实现一个负责渲染和管理它们的更支持动态管理可渲染对象的 primitive；之前的思路是直接转换threejs的mesh，产物就是cesium3js，但是名字太大，误以为是要完全整合cesium和threejs，这与我本意不符遂重新整理优化： 1、不直接支持threejs的mesh，但是支持threejs的geometry和buffergeometry来构建几何体。内置了threejs geometry、buffergeometry到cesium.geometry的转换接口，同时提供cesium.geometry到threejs buffergeometry的转换接口。这些接口由geometryutils类提供。 2、定义mesh，支持cesium.geometry、three.geometry、three.buffergeometry以及csg运算结果模型。 3、更方便的动态渲染和管理。同一个mesh，可以单独修改mesh的位置position、缩放scale、旋转角度rotationquaternion等属性；也可以单独修改 geometry和material；同一个geometry可以单独修改各个属性和索引。方便管理，且减少对象的局部变化带来的整个drawcommand重新构建次数，以期在更多动态渲染 对象同时改变的情况下（比如结合物理引擎做模拟），仍然保持较高的帧率，当然也牺牲了一定的内存。 4、定义meshmaterial，目的是更方便的引用threejs圈的那些炫酷特效shader，减少整合所需的代码量。尤其是cesium的appearance从fragmentshader中分离出material部分的shader，并且作用域不一样之后，带来好多不便，引入网上那些炫酷特效shader的时候真是头疼死了，谁做过谁才解其中味 meshmaterial区别于cesium的material，更像threejs的material但不完全是。。。好像有点四不像 5、定义framebuffertexture，启发于threejs的rendertarget，暂且叫帧缓存纹理类吧，反正名字不重要 meshvisualizer和meshmaterial一起支持此类纹 理，就当是普通的一张图片纹理就好了。它的用处就是，把mesh渲染到帧缓存中，作为纹理参与其他mesh的渲染。可以参考volumerendering示例。另外rendererutils 提供了一个单次执行渲染到纹理的接口rendererutils.rendertotexture。在不使用meshvisualizer的时候，也就是自己基于drawcommand自定义一个primitive的时 候也可以用得上。 6、整合csg.js，支持使用cesium.geometry、three.geometry、three.buffergeometry做交、并、补等运算，并提供将运算结果csg对象转成cesium.geometry、three.geometry的接口。参考csg示例。 7、提供基于ammo.js物理引擎的示例，示例源码源于threejs，使用meshvisualizer，可以在更少的代码修改情况下完成迁移整合，甚合我意。